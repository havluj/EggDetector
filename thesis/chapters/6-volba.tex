\chapter{Implementace Java knihovny}
Pøedmìtem této kapitoly je tvorba softwarové knihovny, která je cílem této práce. Nejdøíve porovnáme vısledky dvou implementací z kapitoly \ref{chap:impl_detekce} a \ref{chap:impl_rozpoz}. Jako další krok budeme diskutovat, jakım zpùsobem integrovat vybranou implementaci do Javy. Následnì se zamìøíme na uivatelské rozhraní knihovny a implementaci. Na závìr vyøešíme distribuci knihovny nástrojem pro správu, øízení a automatizaci buildù aplikací.

\section{Srovnání implementací neuronovıch sítí a volba øešení}
Vzhledem k vısledkùm popsanıch v závìru kapitoly \ref{chap:impl_detekce} a \ref{chap:impl_rozpoz} je zøejmé, e detekce objektù popsaná v kapitole \ref{chap:impl_detekce} je vhodnìjší implementací.

Nicménì vısledná knihovna je navrena tak, e kdykoliv mùeme styl øešení zmìnit bez toho, ani bychom museli mìnit uivatelské rozhraní.

\section{Pouití TensorFlow v Javì}
Abychom mohli pouít model pro detekci vajec v naší knihovnì, je nutné ho exportovat, stejnì jako v kapitole \ref{sec:detekce_funkavysledky}. Exportovanı model umístíme mezi statické zdroje knihovny.

TensorFlow poskytuje API pro jazyk Java. Abychom ho mohli pouívat, staèí pøidat do \texttt{pom.xml} závislost:
\begin{lstlisting}[language=XML]
<dependency>
	<groupId>org.tensorflow</groupId>
	<artifactId>tensorflow</artifactId>
	<version>1.4.0</version>
</dependency>
\end{lstlisting}
Java API, které TensorFlow poskytuje, je pomìrnì nízko-úrovòové~\cite{tensorflowjavaapi}. Abychom si usnadnili práci, pouijeme wrapper\footnote{Tøída, která \uv{obalí} jinou tøídu a pøidá jí funkènost.}, kterı pouívá TensorFlow pro Android. Staèí jen pár drobnıch modifikací a mùeme ho pouít.

\section{Uivatelské rozhraní knihovny}
Pøi tvorbì uivatelského rozhraní vycházíme z prvotního návrhu, kterı vznikl analızou funkèních poadavkù (viz algoritmus \ref{alg:prvni_navrh}). Kompletní dokumentace API, které knihovna uivateli poskytuje je dostupná v pøíloze \ref{chap:dokumentaceapi}. Nejlepším zdrojem ukázek pouití knihovny jsou testy, které diskutujeme v kapitole \ref{chap:overeniatestovani}.

\section{Implementace}
Kompletní zdrojové kódy implementace jsou dostupné v pøíloze \ref{chap:cd}. Knihovnu zkompilujeme nástrojem Maven: \texttt{mvn clean package -DskipTests}.

Neuronová sí, která se stará o detekci a klasifikaci objektù na jednotlivıch snímcích vrací vısledek ve jako mnoinu detekcí. Kadá detekce se skládá z informací o umístìní objektu, typu objektu a pravdìpodobnosti v procentech, e se opravdu o danı objekt jedná. Je tedy nutné stanovit hranici\footnote{Threshold.}, která slouí jako mezník, zda-li je vısledek relevantní, èi nikoliv. Jestlie nastavíme hranici napøíklad na 30\%, knihovna vrátí pouze detekované objekty, u kterıch si je jistá alespoò na 30\%. Kdybychom nastavili hranici na 0\%, knihovna by vrátila všechny moné detekce nalezené v obrázku. Celkovı poèet objektù na snímku je limitován na 100. V kapitole \ref{sec:efektivita_knihovny} se zamìøíme na to, jak nastavená hranice pøináší nejlepší vısledky.

\begin{lstlisting}[caption={Poèítání finálního poètu vajec pro celou sloku pomocí dat z jednotlivıch snímkù.},label={alg:celkovypocetvajec}]
public Integer getFinalCount() {
	TreeMap<Integer, Integer> scores = new TreeMap<>();
	
	for (Integer val : imageScores.values()) {
		if (scores.containsKey(val)) {
			scores.replace(val, scores.get(val) + 1); // increment
		} else {
			scores.put(val, 1);
		}
	}
	
	int bestGuess = 0;
	while (!scores.isEmpty()) {
		Map.Entry<Integer, Integer> e = scores.pollLastEntry();
		if (e.getValue() > 1) { // threshold (how many times do we need the value)
			return e.getKey();
		} else if (e.getValue() == 1) {
			bestGuess = e.getValue();
		}
		
	}
	
	return bestGuess;
}
\end{lstlisting}

\begin{lstlisting}[caption={Transformace vstupního snímku bilineární interpolací.}]
BufferedImage thumbnail = new BufferedImage(INPUT_SIZE, INPUT_SIZE, BufferedImage.TYPE_INT_RGB);
Graphics2D tGraphics2D = thumbnail.createGraphics(); //create a graphics object to paint to
tGraphics2D.setBackground(Color.WHITE);
tGraphics2D.setPaint(Color.WHITE);
tGraphics2D.fillRect(0, 0, INPUT_SIZE, INPUT_SIZE);
tGraphics2D.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
tGraphics2D.drawImage(image, 0, 0, INPUT_SIZE, INPUT_SIZE, null);

// convert img to [INPUT_SIZE, INPUT_SIZE, 3]
BufferedImage convertedImg = new BufferedImage(thumbnail.getWidth(), thumbnail.getHeight(), BufferedImage.TYPE_INT_RGB);
convertedImg.getGraphics().drawImage(thumbnail, 0, 0, null);
\end{lstlisting}

\begin{lstlisting}[caption={Detekce objektù pomocí TensorFlow v Javì.}]
intValues = ((DataBufferInt) convertedImg.getRaster().getDataBuffer()).getData();

for (int i = 0; i < intValues.length; ++i) {
	byteValues[i * 3 + 2] = (byte) (intValues[i] & 0xFF);
	byteValues[i * 3 + 1] = (byte) ((intValues[i] >> 8) & 0xFF);
	byteValues[i * 3 + 0] = (byte) ((intValues[i] >> 16) & 0xFF);
}

// Copy the input data into TensorFlow.
inferenceInterface.feed(INPUT_NAME, byteValues, 1, INPUT_SIZE, INPUT_SIZE, 3);

// Run the inference call.
inferenceInterface.run(outputNames, logStats);

// Copy the output Tensor back into the output array.
outputLocations = new float[MAX_RESULTS * 4];
outputScores = new float[MAX_RESULTS];
outputClasses = new float[MAX_RESULTS];
outputNumDetections = new float[1];
inferenceInterface.fetch(outputNames[0], outputLocations);
inferenceInterface.fetch(outputNames[1], outputScores);
inferenceInterface.fetch(outputNames[2], outputClasses);
inferenceInterface.fetch(outputNames[3], outputNumDetections);
\end{lstlisting}

\section{Distribuce}
Abychom splnili funkèní poadavek \textbf{F2} (viz kapitola \ref{sec:cil_funkcnipozadavky}) o distribuci knihovny, pouijeme \texttt{maven-assembly-plugin}:
\begin{lstlisting}[language=XML]
<plugin>
	<artifactId>maven-assembly-plugin</artifactId>
	<configuration>
		<descriptorRefs>
			<descriptorRef>jar-with-dependencies</descriptorRef>
		</descriptorRefs>
	</configuration>
	<executions>
		<execution>
			<id>make-assembly</id> <!-- this is used for inheritance merges -->
			<phase>package</phase> <!-- bind to the packaging phase -->
			<goals>
				<goal>single</goal>
			</goals>
		</execution>
	</executions>
</plugin>
\end{lstlisting}

\section{Vısledek}
Vısledkem této kapitoly je funkèní softwarová knihovna v jazyce Java, která splòuje všechny cíle stanovené na zaèátku práce. Ke knihovnì je dostupná kompletní uivatelská dokumentace.

Uivatel získá pøístup k detekovanému poètu vajec v poadované sloce (vıpoèet celkového poètu viz alg. \ref{alg:celkovypocetvajec}) i k informacím o jednotlivıch snímcích. Uivatel má monost zmìnit hranici, podle které knihovna urèí, jaká podmnoina vısledkù je relevantní. Napøíklad pøi nastavení hranice na 50\% budou brány v potaz pouze detekce, u kterıch si je knihovna jistá alespoò na 50\%.

Knihovna obsahuje \uv{debuggovací} reim, kterı vizualizuje, jakım zpùsobem jsou detekce reprezentovıny internì. Ukázka \uv{debuggovacího} reimu je vidìt na obrázcích \ref{fig:eggdetectordebug}.

\begin{figure}[ht]
	\centering
	\subfloat{{\includegraphics[width=0.45\textwidth]{media/debug1.png}\label{fig:eggdetectordebug1} }}%
	\qquad
	\subfloat{{\includegraphics[width=0.45\textwidth]{media/debug2.png}\label{fig:eggdetectordebug2} }}%
	\caption{Ukázka debuggovacího reimu knihovny EggDetector.}
	\label{fig:eggdetectordebug}
\end{figure}